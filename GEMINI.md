# Gemini-Generated Project Architecture Guide

## Introduction

This document outlines the standardized architecture for this NestJS, GraphQL, and Prisma project. The goal is to maintain a consistent, clean, and scalable codebase. By adhering to these guidelines, we can ensure that the project remains easy to understand, maintain, and extend over time.

The architecture is based on the principles of **Clean Architecture**, which promotes a separation of concerns and a clear dependency flow.

## Core Principles (Clean Architecture)

The core idea of Clean Architecture is to divide the software into layers, with a strict rule about how they can interact: **The Dependency Rule**. This rule states that source code dependencies can only point inwards. Nothing in an inner layer can know anything at all about something in an outer layer.

Our project is structured into the following layers (from inside out):

1.  **Entities (Domain Layer):** Represents the core business objects and rules. These are the most independent and stable parts of the application.
2.  **Use Cases / Services (Application Layer):** Contains the application-specific business logic. It orchestrates the flow of data between the entities and the outer layers.
3.  **Interface Adapters (Adapter Layer):** This layer is responsible for converting data between the format used by the Use Cases and the format required by external agencies like the database or the web.
4.  **Frameworks & Drivers (Frameworks Layer):** This is the outermost layer, composed of frameworks, tools, and drivers like the database, the web framework, and the UI.

## Project Structure Mapping

Here is how our project's structure maps to the Clean Architecture layers:

| Layer | Directory / File Pattern | Description |
| :--- | :--- | :--- |
| **Entities** | `src/{feature}/{feature}.entity.ts` | Defines the core domain objects. These are plain TypeScript classes decorated with `@ObjectType` for GraphQL. |
| **Use Cases** | `src/{feature}/{feature}.service.ts` | Implements the business logic for a specific feature. It interacts with the `PrismaService` but is unaware of the GraphQL resolver layer. |
| **Interface Adapters** | `src/{feature}/{feature}.resolver.ts` | The GraphQL resolver that handles incoming queries and mutations. It calls the corresponding service to execute business logic. It's the entry point from the web. |
| **Interface Adapters** | `src/{feature}/dto/*.input.ts` | Data Transfer Objects (DTOs) that define the shape of the data for creating and updating entities via the GraphQL API. |
| **Frameworks & Drivers** | `prisma/schema.prisma` | The single source of truth for the database schema. Prisma Client is generated from this file. |
| **Frameworks & Drivers** | `src/prisma/prisma.service.ts` | A service that encapsulates the Prisma Client, making it available for dependency injection throughout the application. |
| **Frameworks & Drivers** | `src/main.ts`, `src/app.module.ts` | The main entry point and root module of the NestJS application. This is where all the modules are tied together. |
| **Frameworks & Drivers** | `src/schema.gql` | The GraphQL schema definition. It is automatically generated by NestJS based on the resolvers and entities. |

## Development Workflow: Adding a New Feature

To add a new feature (e.g., "Comment"), follow these steps to ensure consistency:

1.  **Define the Model:**
    *   Open `prisma/schema.prisma` and add the new model definition.
    ```prisma
    model Comment {
      id        Int      @id @default(autoincrement())
      content   String
      // ... other fields and relations
    }
    ```

2.  **Update Database Schema:**
    *   Run the following command to generate a new migration and update your database schema.
    ```bash
    npx prisma migrate dev --name init-comment
    ```

3.  **Create the Feature Module:**
    *   Create a new directory for your feature: `src/comment`.

4.  **Create the Entity:**
    *   Create `src/comment/comment.entity.ts`. This class represents the `Comment` object in GraphQL.
    ```typescript
    import { ObjectType, Field, Int } from '@nestjs/graphql';

    @ObjectType()
    export class Comment {
      @Field(() => Int)
      id: number;

      @Field()
      content: string;
      // ... other fields
    }
    ```

5.  **Create DTOs:**
    *   Create `src/comment/dto/create-comment.input.ts` and `src/comment/dto/update-comment.input.ts`.
    ```typescript
    // src/comment/dto/create-comment.input.ts
    import { InputType, Field } from '@nestjs/graphql';

    @InputType()
    export class CreateCommentInput {
      @Field()
      content: string;
      // ... other fields
    }
    ```

6.  **Create the Service:**
    *   Create `src/comment/comment.service.ts`. This service will contain all business logic related to comments.
    ```typescript
    import { Injectable } from '@nestjs/common';
    import { PrismaService } from '../prisma/prisma.service';
    import { CreateCommentInput } from './dto/create-comment.input';

    @Injectable()
    export class CommentService {
      constructor(private prisma: PrismaService) {}

      create(createCommentInput: CreateCommentInput) {
        return this.prisma.comment.create({ data: createCommentInput });
      }

      findAll() {
        return this.prisma.comment.findMany();
      }
      // ... other methods
    }
    ```

7.  **Create the Resolver:**
    *   Create `src/comment/comment.resolver.ts`. This will expose the queries and mutations for the `Comment` entity.
    ```typescript
    import { Resolver, Query, Mutation, Args } from '@nestjs/graphql';
    import { CommentService } from './comment.service';
    import { Comment } from './comment.entity';
    import { CreateCommentInput } from './dto/create-comment.input';

    @Resolver(() => Comment)
    export class CommentResolver {
      constructor(private readonly commentService: CommentService) {}

      @Mutation(() => Comment)
      createComment(@Args('createCommentInput') createCommentInput: CreateCommentInput) {
        return this.commentService.create(createCommentInput);
      }

      @Query(() => [Comment], { name: 'comments' })
      findAll() {
        return this.commentService.findAll();
      }
      // ... other resolvers
    }
    ```

8.  **Create the Module:**
    *   Create `src/comment/comment.module.ts` to bundle the resolver and service.
    ```typescript
    import { Module } from '@nestjs/common';
    import { CommentService } from './comment.service';
    import { CommentResolver } from './comment.resolver';
    import { PrismaModule } from '../prisma/prisma.module';

    @Module({
      imports: [PrismaModule],
      providers: [CommentResolver, CommentService],
    })
    export class CommentModule {}
    ```

9.  **Update the Root Module:**
    *   Finally, import the new `CommentModule` into `src/app.module.ts`.
    ```typescript
    // src/app.module.ts
    import { Module } from '@nestjs/common';
    import { CommentModule } from './comment/comment.module';
    // ... other imports

    @Module({
      imports: [
        // ... other modules
        CommentModule,
      ],
    })
    export class AppModule {}
    ```

## Conclusion

By following this structured approach, we can build a robust and maintainable application. This separation of concerns makes the code easier to test, debug, and reason about, allowing for more efficient development and collaboration.
